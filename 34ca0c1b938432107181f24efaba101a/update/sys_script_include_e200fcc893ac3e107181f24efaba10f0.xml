<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>public</access>
        <active>true</active>
        <api_name>x_801257_ets_trans.IncidentStoryIterationHelper</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description>var IncidentStoryIterationHelper = Class.create();&#13;
IncidentStoryIterationHelper.prototype = {&#13;
&#13;
    initialize: function() {&#13;
        // Debug property removed; direct debug statements will work in all environments&#13;
    },&#13;
&#13;
    /**&#13;
     * Checks if UI action should be shown&#13;
     */&#13;
    showAction: function(current) {&#13;
        try {&#13;
            if (!current || !current.isValidRecord()) return false;&#13;
&#13;
            var excludedStates = [6, 7, 8]; // resolved, closed, cancelled&#13;
            var stateValue = parseInt(current.state, 10);&#13;
            if (excludedStates.indexOf(stateValue) !== -1) {&#13;
                gs.debug('UI Action hidden: Incident state ' + stateValue);&#13;
                return false;&#13;
            }&#13;
&#13;
            var teamSysId = this._getTeamMappingForRecord(current);&#13;
            if (!teamSysId) {&#13;
                gs.debug('UI Action hidden: No team mapping for assignment group ' +&#13;
                         (current.assignment_group.getDisplayValue() || current.assignment_group));&#13;
                return false;&#13;
            }&#13;
&#13;
            gs.debug('UI Action visible for incident ' + current.number);&#13;
            return true;&#13;
&#13;
        } catch (ex) {&#13;
            gs.warn('Error in showAction(): ' + ex.message);&#13;
            return false;&#13;
        }&#13;
    },&#13;
&#13;
    /**&#13;
     * Main function to create or link Story&#13;
     */&#13;
    createStoryInTeamIteration: function(recordSysId, tableName) {&#13;
        try {&#13;
            var record = this._getRecordBySysId(recordSysId, tableName);&#13;
            if (!record) return { success: false, message: 'Record not found' };&#13;
&#13;
            var teamSysId = this._getTeamMappingForRecord(record);&#13;
            if (!teamSysId) return { success: false, message: 'No team mapping' };&#13;
&#13;
            // Check existing story and reassign if team changed&#13;
            var reassignmentResult = this._checkAndReassignStoryIfNeeded(record, teamSysId);&#13;
            if (reassignmentResult.status === 'same_team' || reassignmentResult.status === 'reassigned') {&#13;
                return {&#13;
                    success: true,&#13;
                    sys_id: record.agile_story ? record.agile_story.sys_id : '',&#13;
                    storyNumber: reassignmentResult.storyNumber,&#13;
                    status: reassignmentResult.status,&#13;
                    iterationName: reassignmentResult.iterationName,&#13;
                    teamName: reassignmentResult.teamName,&#13;
                    message: reassignmentResult.status === 'reassigned' ?&#13;
                        'Story reassigned to new team' : 'Story already exists for same team'&#13;
                };&#13;
            }&#13;
&#13;
            var teamGR = new GlideRecord('sn_apw_advanced_eap_team');&#13;
            if (!teamGR.get(teamSysId)) return { success: false, message: 'Invalid team mapping' };&#13;
            var teamName = teamGR.name.toString();&#13;
&#13;
            var iteration = this._getCurrentIterationForTeam(teamSysId);&#13;
&#13;
            // Single GlideRecord for rm_story reused&#13;
            var storyGR = new GlideRecord('rm_story');&#13;
&#13;
            // Check existing story (for completeness)&#13;
            var existing = this._checkExistingStory(record, teamName, storyGR);&#13;
            if (existing.exists) return existing;&#13;
&#13;
            // Create new story&#13;
            return this._createNewStory(record, teamSysId, teamName, iteration, storyGR);&#13;
&#13;
        } catch (ex) {&#13;
            gs.error('Error in createStoryInTeamIteration: ' + ex.message + '\n' + ex.stack);&#13;
            return { success: false, message: 'Unexpected error: ' + ex.message };&#13;
        }&#13;
    },&#13;
&#13;
    /**&#13;
     * Check if a story already exists for the record&#13;
     */&#13;
    _checkExistingStory: function(record, teamName, storyGR) {&#13;
        storyGR.addQuery('original_task', record.sys_id);&#13;
        storyGR.query();&#13;
&#13;
        if (storyGR.next()) {&#13;
            if (record.isValidField('agile_story') &amp;&amp; !record.agile_story) {&#13;
                record.agile_story = storyGR.sys_id;&#13;
                record.update();&#13;
            }&#13;
&#13;
            if (storyGR.isValidField('work_notes')) {&#13;
                storyGR.work_notes = 'This story (' + storyGR.number + ') is already linked to triage Incident ' + record.number + '.';&#13;
                storyGR.update();&#13;
            }&#13;
&#13;
            gs.debug('Existing story found: ' + storyGR.number + ' for Incident ' + record.number);&#13;
&#13;
            return {&#13;
                success: true,&#13;
                exists: true,&#13;
                sys_id: storyGR.sys_id.toString(),&#13;
                storyNumber: storyGR.number.toString(),&#13;
                status: 'existing',&#13;
                iterationName: storyGR.getDisplayValue('iteration'),&#13;
                teamName: teamName,&#13;
                message: 'Existing story found'&#13;
            };&#13;
        }&#13;
&#13;
        return { exists: false };&#13;
    },&#13;
&#13;
    /**&#13;
     * Create a new story (or backlog story if no iteration)&#13;
     */&#13;
    _createNewStory: function(record, teamSysId, teamName, iteration, storyGR) {&#13;
        storyGR.initialize();&#13;
        storyGR.short_description = record.short_description || record.number || ('Story for ' + record.getTableName());&#13;
        storyGR.description = record.description || '';&#13;
        storyGR.original_task = record.sys_id;&#13;
        storyGR.eap_team = teamSysId;&#13;
        storyGR.iteration = iteration ? iteration.sys_id : null;&#13;
        var storySysId = storyGR.insert();&#13;
&#13;
        // Add work notes to Story&#13;
        if (storyGR.isValidField('work_notes')) {&#13;
            var iterationText = iteration ? ' in iteration ' + iteration.name : '';&#13;
            var backlogText = !iteration ? ' (no iteration, added to backlog)' : '';&#13;
            storyGR.work_notes = 'This story (' + storyGR.number + ') was created from triage Incident ' +&#13;
                                 record.number + iterationText + ' for team ' + teamName + backlogText + '.';&#13;
            storyGR.update();&#13;
        }&#13;
&#13;
        // Link back to Incident&#13;
        if (record.isValidField('agile_story')) {&#13;
            record.agile_story = storySysId;&#13;
            record.update();&#13;
        }&#13;
&#13;
        gs.debug('Created new story: ' + storyGR.number + ' for Incident ' + record.number);&#13;
&#13;
        return {&#13;
            success: true,&#13;
            exists: false,&#13;
            sys_id: storySysId,&#13;
            storyNumber: storyGR.number.toString(),&#13;
            status: iteration ? 'new' : 'backlog',&#13;
            iterationName: iteration ? iteration.name : null,&#13;
            teamName: teamName,&#13;
            message: 'Story created successfully'&#13;
        };&#13;
    },&#13;
&#13;
    /**&#13;
     * Check if story exists and reassign if team changed&#13;
     */&#13;
    _checkAndReassignStoryIfNeeded: function(record, mappedTeamSysId) {&#13;
        try {&#13;
            var storyGR = new GlideRecord('rm_story');&#13;
            storyGR.addQuery('original_task', record.sys_id);&#13;
            storyGR.query();&#13;
&#13;
            if (!storyGR.next()) return { status: 'no_story' };&#13;
&#13;
            var existingTeam = storyGR.getValue('eap_team') || storyGR.getValue('team') || '';&#13;
            var existingIteration = storyGR.getDisplayValue('iteration') || '';&#13;
            var storyNumber = storyGR.number.toString();&#13;
&#13;
            if (existingTeam === mappedTeamSysId) {&#13;
                gs.debug('Story ' + storyNumber + ' already in the same team.');&#13;
&#13;
                if (record.isValidField('agile_story') &amp;&amp; !record.agile_story) {&#13;
                    record.agile_story = storyGR.sys_id;&#13;
                    record.update();&#13;
                }&#13;
&#13;
                if (storyGR.isValidField('work_notes')) {&#13;
                    storyGR.work_notes = 'Story (' + storyNumber + ') is already linked to triage Incident ' + record.number + '.';&#13;
                    storyGR.update();&#13;
                }&#13;
&#13;
                return {&#13;
                    status: 'same_team',&#13;
                    storyNumber: storyNumber,&#13;
                    iterationName: existingIteration,&#13;
                    teamName: this._getTeamName(existingTeam)&#13;
                };&#13;
            }&#13;
&#13;
            // Team changed â†’ reassign&#13;
            var newIteration = this._getCurrentIterationForTeam(mappedTeamSysId);&#13;
            storyGR.setValue('eap_team', mappedTeamSysId);&#13;
            storyGR.setValue('iteration', newIteration ? newIteration.sys_id : '');&#13;
            storyGR.update();&#13;
&#13;
            var teamName = this._getTeamName(mappedTeamSysId);&#13;
            var iterationText = newIteration ? (' moved to iteration ' + newIteration.name) : ' (no iteration, added to backlog)';&#13;
&#13;
            if (storyGR.isValidField('work_notes')) {&#13;
                storyGR.work_notes = 'ðŸ”„ Story reassigned to team ' + teamName + iterationText + '.';&#13;
                storyGR.update();&#13;
            }&#13;
&#13;
            gs.debug('Story ' + storyNumber + ' reassigned to team ' + teamName);&#13;
&#13;
            return {&#13;
                status: 'reassigned',&#13;
                storyNumber: storyNumber,&#13;
                iterationName: newIteration ? newIteration.name : null,&#13;
                teamName: teamName&#13;
            };&#13;
&#13;
        } catch (ex) {&#13;
            gs.error('Error in _checkAndReassignStoryIfNeeded(): ' + ex.message);&#13;
            return { status: 'error', message: ex.message };&#13;
        }&#13;
    },&#13;
&#13;
    /**&#13;
     * Get team mapping based on assignment group from system property&#13;
     */&#13;
    _getTeamMappingForRecord: function(current) {&#13;
        if (!current || !current.assignment_group) return null;&#13;
&#13;
        var tableName = current.getTableName();&#13;
        var propName = 'x_801257_ets_trans.eap.story.auto_create.group_backlog_mapping.' + tableName;&#13;
        var propValue = gs.getProperty(propName, '{}');&#13;
        var map = JSON.parse(propValue);&#13;
&#13;
        var groupId = current.assignment_group.toString();&#13;
        if (map[groupId] &amp;&amp; map[groupId].team) return map[groupId].team;&#13;
&#13;
        gs.debug('No team mapping found for assignment group ' + current.assignment_group.getDisplayValue());&#13;
        return null;&#13;
    },&#13;
&#13;
    _getTeamName: function(teamSysId) {&#13;
        if (!teamSysId) return 'Unknown Team';&#13;
        var teamGR = new GlideRecord('sn_apw_advanced_eap_team');&#13;
        if (teamGR.get(teamSysId)) return teamGR.name.toString();&#13;
        return 'Unknown Team';&#13;
    },&#13;
&#13;
    _getRecordBySysId: function(sysId, tableName) {&#13;
        if (!sysId || !tableName) return null;&#13;
        var gr = new GlideRecord(tableName);&#13;
        return gr.get(sysId) ? gr : null;&#13;
    },&#13;
&#13;
    _getCurrentIterationForTeam: function(teamSysId) {&#13;
        var iterationGR = new GlideRecord('sn_apw_advanced_eap_iteration');&#13;
        iterationGR.addQuery('eap_team', teamSysId);&#13;
        iterationGR.addQuery('state', 'current');&#13;
        iterationGR.orderByDesc('start_date');&#13;
        iterationGR.setLimit(1);&#13;
        iterationGR.query();&#13;
&#13;
        if (iterationGR.next()) {&#13;
            gs.debug('Found current iteration: ' + iterationGR.name);&#13;
            return { sys_id: iterationGR.sys_id.toString(), name: iterationGR.name.toString() };&#13;
        }&#13;
&#13;
        gs.debug('No current iteration found for team ' + teamSysId);&#13;
        return null;&#13;
    },&#13;
&#13;
    type: 'IncidentStoryIterationHelper'&#13;
};&#13;
</description>
        <mobile_callable>false</mobile_callable>
        <name>IncidentStoryIterationHelper</name>
        <sandbox_callable>false</sandbox_callable>
        <script><![CDATA[var IncidentStoryIterationHelper = Class.create();
IncidentStoryIterationHelper.prototype = {

    initialize: function() {
        // No debug property; gs.debug() works directly
    },

    /**
     * Checks if UI action should be shown
     */
    showAction: function(current) {
        try {
            if (!current || !current.isValidRecord()) return false;

            var excludedStates = [6, 7, 8]; // resolved, closed, cancelled
            var stateValue = parseInt(current.state, 10);
            if (excludedStates.indexOf(stateValue) !== -1) {
                gs.debug('UI Action hidden: Incident state ' + stateValue);
                return false;
            }

            var teamSysId = this._getTeamMappingForRecord(current);
            if (!teamSysId) {
                gs.debug('UI Action hidden: No team mapping for assignment group ' +
                         (current.assignment_group.getDisplayValue() || current.assignment_group));
                return false;
            }

            gs.debug('UI Action visible for incident ' + current.number);
            return true;

        } catch (ex) {
            gs.warn('Error in showAction(): ' + ex.message);
            return false;
        }
    },

    /**
     * Main function to create or link Story
     */
    createStoryInTeamIteration: function(recordSysId, tableName) {
        try {
            var record = this._getRecordBySysId(recordSysId, tableName);
            if (!record) return { success: false, message: 'Record not found' };

            var teamSysId = this._getTeamMappingForRecord(record);
            if (!teamSysId) {
                gs.debug('Cannot create story: Team mapping does not exist.');
                return { success: false, message: 'Team does not exist' };
            }

            // Check if team actually exists
            var teamGR = new GlideRecord('sn_apw_advanced_eap_team');
            if (!teamGR.get(teamSysId)) {
                gs.debug('Cannot create story: Team with sys_id ' + teamSysId + ' does not exist.');
                return { success: false, message: 'Team does not exist' };
            }

            // Check existing story and update/reassign if needed
            var reassignmentResult = this._checkAndUpdateStory(record, teamSysId);
            if (['same_team', 'reassigned', 'iteration_updated'].includes(reassignmentResult.status)) {
                return {
                    success: true,
                    sys_id: reassignmentResult.sys_id,
                    storyNumber: reassignmentResult.storyNumber,
                    status: reassignmentResult.status,
                    iterationName: reassignmentResult.iterationName,
                    teamName: reassignmentResult.teamName,
                    message: reassignmentResult.message
                };
            }

            // Create new story
            return this._createNewStory(record, teamSysId);

        } catch (ex) {
            gs.error('Error in createStoryInTeamIteration: ' + ex.message + '\n' + ex.stack);
            return { success: false, message: 'Unexpected error: ' + ex.message };
        }
    },

    /**
     * Check existing story or reassign/update iteration if needed
     */
    _checkAndUpdateStory: function(record, mappedTeamSysId) {
        try {
            var storyGR = new GlideRecord('rm_story');
            storyGR.addQuery('original_task', record.sys_id);
            storyGR.query();

            if (!storyGR.next()) return { status: 'no_story' };

            var existingTeam = storyGR.getValue('eap_team') || '';
            var existingIterationId = storyGR.getValue('iteration') || '';
            var storyNumber = storyGR.number.toString();
            var storySysId = storyGR.sys_id.toString();
            var newIteration = this._getCurrentIterationForTeam(mappedTeamSysId);

            // Case 1: Team changed
            if (existingTeam !== mappedTeamSysId) {
                storyGR.setValue('eap_team', mappedTeamSysId);
                storyGR.setValue('iteration', newIteration ? newIteration.sys_id : '');
                storyGR.update();

                var teamName = this._getTeamName(mappedTeamSysId);

                gs.debug('Story ' + storyNumber + ' reassigned to team ' + teamName);

                return {
                    status: 'reassigned',
                    sys_id: storySysId,
                    storyNumber: storyNumber,
                    iterationName: newIteration ? newIteration.name : null,
                    teamName: teamName,
                    message: 'Story reassigned to new team'
                };
            }

            // Case 2: Same team but iteration changed
            var currentIterationId = newIteration ? newIteration.sys_id : '';
            if (existingIterationId !== currentIterationId) {
                storyGR.setValue('iteration', currentIterationId);
                storyGR.update();

                var teamName = this._getTeamName(mappedTeamSysId);

                gs.debug('Story ' + storyNumber + ' iteration updated for team ' + teamName);

                return {
                    status: 'iteration_updated',
                    sys_id: storySysId,
                    storyNumber: storyNumber,
                    iterationName: newIteration ? newIteration.name : null,
                    teamName: teamName,
                    message: 'Story iteration updated'
                };
            }

            // Case 3: Same team, same iteration
            return {
                status: 'same_team',
                sys_id: storySysId,
                storyNumber: storyNumber,
                iterationName: newIteration ? newIteration.name : null,
                teamName: this._getTeamName(mappedTeamSysId),
                message: 'Story already linked to same team and iteration'
            };

        } catch (ex) {
            gs.error('Error in _checkAndUpdateStory(): ' + ex.message);
            return { status: 'error', message: ex.message };
        }
    },

    /**
     * Create a new story
     */
    _createNewStory: function(record, teamSysId) {
        var iteration = this._getCurrentIterationForTeam(teamSysId);
        var storyGR = new GlideRecord('rm_story');
        storyGR.initialize();
        storyGR.short_description = record.short_description || record.number || ('Story for ' + record.getTableName());
        storyGR.description = record.description || '';
        storyGR.original_task = record.sys_id;
        storyGR.eap_team = teamSysId;
        storyGR.iteration = iteration ? iteration.sys_id : null;
        var storySysId = storyGR.insert();

        gs.debug('Created new story: ' + storyGR.number + ' for Incident ' + record.number);

        return {
            success: true,
            exists: false,
            sys_id: storySysId,
            storyNumber: storyGR.number.toString(),
            status: iteration ? 'new' : 'backlog',
            iterationName: iteration ? iteration.name : null,
            teamName: this._getTeamName(teamSysId),
            message: 'Story created successfully'
        };
    },

    _getTeamMappingForRecord: function(current) {
        if (!current || !current.assignment_group) return null;

        var tableName = current.getTableName();
        var propName = 'x_801257_ets_trans.eap.story.auto_create.group_backlog_mapping.' + tableName;
        var propValue = gs.getProperty(propName, '{}');
        var map = JSON.parse(propValue);

        var groupId = current.assignment_group.toString();
        if (map[groupId] && map[groupId].team) return map[groupId].team;

        gs.debug('No team mapping found for assignment group ' + current.assignment_group.getDisplayValue());
        return null;
    },

    _getTeamName: function(teamSysId) {
        if (!teamSysId) return 'Unknown Team';
        var teamGR = new GlideRecord('sn_apw_advanced_eap_team');
        if (teamGR.get(teamSysId)) return teamGR.name.toString();
        return 'Unknown Team';
    },

    _getRecordBySysId: function(sysId, tableName) {
        if (!sysId || !tableName) return null;
        var gr = new GlideRecord(tableName);
        return gr.get(sysId) ? gr : null;
    },

    _getCurrentIterationForTeam: function(teamSysId) {
        var iterationGR = new GlideRecord('sn_apw_advanced_eap_iteration');
        iterationGR.addQuery('eap_team', teamSysId);
        iterationGR.addQuery('state', 'current');
        iterationGR.orderByDesc('start_date');
        iterationGR.setLimit(1);
        iterationGR.query();

        if (iterationGR.next()) {
            gs.debug('Found current iteration: ' + iterationGR.name);
            return { sys_id: iterationGR.sys_id.toString(), name: iterationGR.name.toString() };
        }

        gs.debug('No current iteration found for team ' + teamSysId);
        return null;
    },

    type: 'IncidentStoryIterationHelper'
};
]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2025-10-07 17:02:58</sys_created_on>
        <sys_id>e200fcc893ac3e107181f24efaba10f0</sys_id>
        <sys_mod_count>64</sys_mod_count>
        <sys_name>IncidentStoryIterationHelper</sys_name>
        <sys_package display_value="ETS Transformation" source="x_801257_ets_trans">34ca0c1b938432107181f24efaba101a</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="ETS Transformation">34ca0c1b938432107181f24efaba101a</sys_scope>
        <sys_update_name>sys_script_include_e200fcc893ac3e107181f24efaba10f0</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2025-10-17 18:34:13</sys_updated_on>
    </sys_script_include>
</record_update>
